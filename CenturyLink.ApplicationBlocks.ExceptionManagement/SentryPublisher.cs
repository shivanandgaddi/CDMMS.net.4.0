// CSP2 dll source and its test code

using System;
using System.Net;
using System.Collections;
using System.Collections.Specialized;
using System.Threading;
using System.Diagnostics;
using System.Globalization;
using System.Security.Permissions;
using Microsoft.ApplicationBlocks.ExceptionManagement;

[assembly: System.Runtime.InteropServices.ComVisible(false)]
[assembly:CLSCompliant(true)]


namespace CenturyLink.ApplicationBlocks.ExceptionManagement
{
	//------ BEGIN EventService.cs autogenerated by wsdl.exe from the wsdl file --------
	//------------------------------------------------------------------------------
	// <autogenerated>
	//     This code was generated by a tool.
	//     Runtime Version: 1.1.4322.2032
	//
	//     Changes to this file may cause incorrect behavior and will be lost if 
	//     the code is regenerated.
	// </autogenerated>
	//------------------------------------------------------------------------------

	// 
	// This source code was auto-generated by wsdl, Version=1.1.4322.2032.
	// 

	/// <remarks/>
	[System.Diagnostics.DebuggerStepThroughAttribute()]
	[System.ComponentModel.DesignerCategoryAttribute("code")]
	[System.Web.Services.WebServiceBindingAttribute(Name="EventBinding", Namespace="urn:SentryEvent")]
	public class EventService : System.Web.Services.Protocols.SoapHttpClientProtocol 
	{
    
		/// <remarks/>
		public EventService() 
		{
			this.Url = "http://localhost:9911/wsi/event";
		}
    
		/// <remarks/>
		[System.Web.Services.Protocols.SoapDocumentMethodAttribute("", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Bare)]
		[return: System.Xml.Serialization.XmlElementAttribute("EventResponse", Namespace="urn:SentryEvent")]
		public string EventRequest([System.Xml.Serialization.XmlArrayAttribute(Namespace="urn:SentryEvent")] [System.Xml.Serialization.XmlArrayItemAttribute("field", Form=System.Xml.Schema.XmlSchemaForm.Unqualified, Namespace="urn:SentryEvent", IsNullable=false)] EventField[] Event) 
		{
			object[] results = this.Invoke("EventRequest", new object[] {
																			Event});
			return ((string)(results[0]));
		}
    
		/// <remarks/>
		public System.IAsyncResult BeginEventRequest(EventField[] Event, System.AsyncCallback callback, object asyncState) 
		{
			return this.BeginInvoke("EventRequest", new object[] {
																	 Event}, callback, asyncState);
		}
    
		/// <remarks/>
		public string EndEventRequest(System.IAsyncResult asyncResult) 
		{
			object[] results = this.EndInvoke(asyncResult);
			return ((string)(results[0]));
		}
	}

	/// <remarks/>
	[System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:SentryEvent")]
	public class EventField 
	{
    
		/// <remarks/>
		[System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
		public string name;
    
		/// <remarks/>
		[System.Xml.Serialization.XmlElementAttribute(Form=System.Xml.Schema.XmlSchemaForm.Unqualified)]
		public string value;
	}

	//---- END EventService.cs autogenerated by wsdl.exe from the wsdl file ---------
	//-------------------------------------------------------------------------------

	class Severity 
	{
		public readonly string name;
		public readonly int ordinal;

		private static readonly ArrayList instanceList = new ArrayList();

		public static readonly Severity IGNORE		= new Severity("ignore",	Int32.MaxValue);
		public static readonly Severity CRITICAL	= new Severity("critical",	1);
		public static readonly Severity MAJOR		= new Severity("major",		2);
		public static readonly Severity MINOR		= new Severity("minor",		3);
		public static readonly Severity WARNING		= new Severity("warning",	4);
		public static readonly Severity NORMAL		= new Severity("normal",	5);
		public static readonly Severity UNKNOWN		= new Severity("unknown",	6);
        public static readonly Severity DEBUG		= new Severity("debug",	    7);
        public static readonly Severity INFO		= new Severity("info",  	8);

		public static readonly Severity[] array = (Severity[]) 
			(instanceList.ToArray(typeof(Severity)));

		private Severity(string name, int ordinal) 
		{
			this.name = name;
			this.ordinal = ordinal;

			instanceList.Add(this);
		}

		public static Severity ValueOf(string s)
		{
			if (s == null || s.Length == 0) 
			{
				return null;
			}

			s = s.ToLower();
			for (int i = 0; i < array.Length; i++) 
			{
				Severity sev = array[i];
				if (s.Equals(sev.name)) 
				{
					return sev;
				}
			}

			return null;
		}

		public override string ToString() 
		{
			return name;
		}
	}

	class EventAttributeType 
	{
		public readonly string name;
		public readonly string defaultValue;

		private static readonly ArrayList instanceList = new ArrayList();

		public static readonly EventAttributeType SEVERITY		= new EventAttributeType("severity",	"major");
		public static readonly EventAttributeType IDENTIFIER	= new EventAttributeType("identifier",	"9999");
		public static readonly EventAttributeType APPLICATION	= new EventAttributeType("application", "unspecifiedDOTNET");
		public static readonly EventAttributeType MESSAGE		= new EventAttributeType("message",		"no event message specified");
		public static readonly EventAttributeType SUBSYSTEM		= new EventAttributeType("subsystem",	"Custom Sentry Publisher V2");
		public static readonly EventAttributeType OBJECT		= new EventAttributeType("object",		null);
		public static readonly EventAttributeType CLASSINFO		= new EventAttributeType("classinfo",	null);
		public static readonly EventAttributeType SOURCEHOST	= new EventAttributeType("sourcehost",	Dns.GetHostName());

		public static readonly EventAttributeType[] array = (EventAttributeType[]) 
			(instanceList.ToArray(typeof(EventAttributeType)));

		private EventAttributeType(string name, string defaultValue) 
		{
			this.name = name;
			this.defaultValue = defaultValue;

			instanceList.Add(this);
		}

		public static EventAttributeType ValueOf(string s) 
		{
			if (s == null || s.Length == 0) 
			{
				return null;
			}

			s = s.ToLower();

			if (s.StartsWith("sentry."))
			{
				// common expected case
				s = s.Substring(7); // skip "sentry."
			}
			else if (s.StartsWith("sentry"))
			{
				// legacy case
				s = s.Substring(6); // skip "sentry"
			}
			else
			{
				// the key is not an event attribute
				return null;
			}

			for (int i = 0; i < array.Length; i++) 
			{
				EventAttributeType attrib = array[i];
				if (s.Equals(attrib.name)) 
				{
					return attrib;
				}
			}

			return null;
		}

		public override string ToString() 
		{
			return name;
		}
	}

	// container of an event attribute and its value
	class AttributeValuePair
	{
		public readonly EventAttributeType attribute;
		public readonly string value;
		
		public AttributeValuePair(EventAttributeType attribute, string value) 
		{
			this.attribute = attribute;
			this.value = value;
		}
	}

	// event record containing attribute-value pairs
	class EventRecord
	{
		public readonly AttributeValuePair[] attributeValuePairs;

		public EventRecord(AttributeValuePair[] attributeValuePairs)
		{
			this.attributeValuePairs = attributeValuePairs;

		}
	}

	// Contains the mechanism to process a queue of events in an asynchrinous way using a dedicated thread
	class QueueProcessor
	{
		private enum ExceptionType  : int {None, WebException, SoapException, UnknownException};

		private static EventService sentryEventService; // for sending WS requests; EventService class created from WSDL
		private static int queueLimit; // max number of items that can be put in the queue
		private static Queue queue; // holds the queue items
		private static int queueClearThreshold; // if count drops to this, then queue is considered "cleared"

		private static Thread thread; // dedicated thread to send the events from the queue

		private static bool overloadCondition; // to indicate overrun occurred and queue is not "cleared" yet
		private static int numEventsDropped; // number of events dropped while overloadCondition is true
		private static EventRecord specialEvent; // Queue Full event or Queue Clear event
		private static DateTime overrunStartTime; // time stamp when the overrun occurred


		private QueueProcessor()
		{
		}

		// this sets up the queue processor when Publisher is initialized
		public static void Initialize(string sentryURL, int queueLimit)
		{
			const double queueClearThresholdRatio = 0.10; // queue is considered cleared if 10% or less is full
			const int WS_REQ_TIMEOUT = 10*1000; // 10 secs timeout for completing a web service request
			
			sentryEventService = new EventService();
			sentryEventService.Url = sentryURL;
			sentryEventService.Timeout = WS_REQ_TIMEOUT;

			QueueProcessor.queueLimit = queueLimit;

			queue = new Queue(QueueProcessor.queueLimit);
			queueClearThreshold = (int)(queueLimit * queueClearThresholdRatio);

			thread = new Thread(new ThreadStart(ProcessQueue));
			thread.Name = "CSP QueueProcessor";
			thread.IsBackground = true;
			thread.Start();

			// initialize the run-time state variables that can keep changing after initialization
			overloadCondition = false;
			numEventsDropped = 0;
			specialEvent = null;
		}

		// Extracts (from the dedicated thread) an event from the queue, unless a special event is scheduled
		// in which case pick that special event.
		private static EventRecord Dequeue() 
		{
			EventRecord retEvent = null;

			lock (queue) 
			{
				if (specialEvent != null) 
				{
					retEvent = specialEvent;
					specialEvent = null;
					return retEvent;
				}

				while (queue.Count == 0) 
				{
					try 
					{
						Monitor.Wait(queue);
					} 
					catch
					{
						//Console.WriteLine("Exception while in Monitor.Wait: " + e);
					}
				}

				retEvent = (EventRecord) queue.Dequeue();

				if (overloadCondition && queue.Count <= queueClearThreshold) 
				{
					overloadCondition = false;

					// arranage to have a QUEUE CLEAR event sent
					string messageField = "QUEUE CLEAR: Queue has cleared. Dropped " + numEventsDropped + 
						" events since " + overrunStartTime;
					numEventsDropped = 0;
					specialEvent = CreateSpecialEvent(retEvent, messageField, 9000, Severity.NORMAL);
				}

				return retEvent;
			}
		}

		// convert to a form that is usable by the WSDL generated EventService class
		private static EventField[] GetEventFields(EventRecord ev)
		{
			EventField[] eventFields = new EventField[ev.attributeValuePairs.Length];
	
			for (int i = 0; i < eventFields.Length; i++) 
			{
				AttributeValuePair attributeValuePair = ev.attributeValuePairs[i];

				EventField eventField = new EventField();
				eventField.name = attributeValuePair.attribute.name;
				eventField.value = attributeValuePair.value;

				eventFields[i] = eventField;
			}

			return eventFields;
		}

		// Attempt to send the web service request and catch any exception. Return detailed exception info
		// if exception occurs.
		private static Exception HandleWebServiceRequest(EventRecord eventRecord, 
			out ExceptionType exceptionType, out string exceptionMessage) 
		{
			exceptionType = ExceptionType.None;
			exceptionMessage = null;
			Exception exception = null;
			string exceptionMessageExtra = null;

			string retMesg = null;
			try 
			{
				retMesg = sentryEventService.EventRequest( GetEventFields(eventRecord) );
			}
			catch (WebException we) 
			{
				//  Common cases where this can happen:
				//  - DNS resolution error
				//	- connection refused
				//	- timeout

				exception = we;
				exceptionType = ExceptionType.WebException;

				exceptionMessageExtra = "WebException Status = " + we.Status;
				HttpWebResponse response = (HttpWebResponse)we.Response;
				if (response != null) 
				{
					exceptionMessageExtra = exceptionMessageExtra + 
						" HttpWebResponse StatusCode = " + response.StatusCode +
						" StatusDescription = " + response.StatusDescription;
				}
			}
			catch (System.Web.Services.Protocols.SoapException se) 
			{
				// Common cases where this can happen:
				//	- mailformed url post request
				//	- illegal event field value

				exception = se;
				exceptionType = ExceptionType.SoapException;
			}
			catch(Exception ue) 
			{
				// unknown general exception
 
				exception = ue;
				exceptionType = ExceptionType.UnknownException;
			} 

			if (exception != null) 
			{
				exceptionMessage = 	exception.GetType() + ": " +  exception.Message + "; " + exceptionMessageExtra;
				//Console.WriteLine(exceptionMessage);
			} 
			else 
			{
				//Console.WriteLine(retMesg);
			}
	
			return exception;
		}

		// publish event - retry if necessary
		private static void ProcessQueueItem(EventRecord eventRecord)
		{
			const int SHORT_PAUSE = 15*1000; // 15 secs wait period during a series of consecutive retrials
			const int LONG_PAUSE = 5*60*1000; // 5 minutues wait period after MAX_CONSECUTIVE_ATTEMPTS retrials
			const int MAX_CONSECUTIVE_ATTEMPTS = 3;  // number of retrial attempts before taking a long pause

			bool done = false;
			int attemptCount = 0;

			while (!done)
			{
				Exception exception = null;
				ExceptionType exceptionType;
				string exceptionMessage;

				exception = HandleWebServiceRequest(eventRecord, out exceptionType, out exceptionMessage);
				attemptCount++;

				if (exception == null) 
				{
					done = true;
				} 
				else if (exceptionType != ExceptionType.WebException) 
				{
                    // commented since we getting this back for invalid severity levels..
					SentryPublisher.LogToEventLog(exceptionMessage);

					// no point retrying since the same outcome is excepted to happen
					done = true;
				}
				else
				{
					// Here exceptionType is WebException and so retrial may be worthwhile

					if (attemptCount < MAX_CONSECUTIVE_ATTEMPTS) 
					{
						Thread.Sleep(SHORT_PAUSE);
					} 
					else 
					{
						SentryPublisher.LogToEventLog(exceptionMessage);

						// resume retrial after a long pause
						Thread.Sleep(LONG_PAUSE);
						attemptCount = 0;
					}
				} 
			}
		}

		// the method that the queue processor thread runs
		public static void ProcessQueue() 
		{
			while ( true ) 
			{
				EventRecord queueItem = Dequeue();
				ProcessQueueItem(queueItem);
			}
		}

		// get the value of an event attribute from event; if not found return default
		private static string getValueOfAttribute(EventAttributeType attrib, EventRecord eventRecord)
		{
			string value = attrib.defaultValue;

			for (int i = 0; i < eventRecord.attributeValuePairs.Length; i++)
			{
				AttributeValuePair attributeValuePair = eventRecord.attributeValuePairs[i];
				if (attributeValuePair.attribute == attrib) 
				{
					value = attributeValuePair.value;
					break;
				}
			}

			return value;
		}

		// create a special event (queue full or queue clear)
		private static EventRecord CreateSpecialEvent(EventRecord eventRecord, string message, 
			int identifier, Severity severity)
		{
			string appID = getValueOfAttribute(EventAttributeType.APPLICATION, eventRecord);

			AttributeValuePair[] attributeValuePairs = new AttributeValuePair[] 
				{
					new AttributeValuePair(EventAttributeType.SEVERITY,		severity.name),
					new AttributeValuePair(EventAttributeType.IDENTIFIER,	(identifier + "")),
					new AttributeValuePair(EventAttributeType.APPLICATION,	appID),
					new AttributeValuePair(EventAttributeType.MESSAGE,		message),
					new AttributeValuePair(EventAttributeType.SUBSYSTEM,	EventAttributeType.SUBSYSTEM.defaultValue),
					new AttributeValuePair(EventAttributeType.OBJECT,		"Custom Sentry Publisher Queue"),
					new AttributeValuePair(EventAttributeType.SOURCEHOST,	EventAttributeType.SOURCEHOST.defaultValue)
				};

			return new EventRecord(attributeValuePairs);
		}

		// enqueue an event to the queue processor's queue
		public static void Enqueue(EventRecord eventRecord) 
		{
			lock (queue)
			{
				if (queue.Count < queueLimit) 
				{
					queue.Enqueue(eventRecord);
					Monitor.Pulse(queue); // wake up the thread if it is waiting
				} 
				else 
				{
					// Drop the event
					numEventsDropped++;

					if ( ! overloadCondition ) 
					{
						overloadCondition = true;
						overrunStartTime = DateTime.Now;

						// arranage to have a QUEUE FULL event sent
						string messageField = "QUEUE FULL: Queue overrun occurred: started dropping events";
						specialEvent = CreateSpecialEvent(eventRecord, messageField, 9911, Severity.MAJOR);
						Monitor.Pulse(queue); // wake up the thread if it is waiting
					}
				}
			}
		}
	}

	// Publisher class
	public class SentryPublisher : IExceptionPublisher
	{	
		private static bool sentryPublisherInitialized = false;
        private static Hashtable configEventAttributeMap = null;
        private const string logType = "LogType";
        private const string EXCEPTION = "EXCEPTION";
        private const string ALARM = "ALARM";
	
		public SentryPublisher() 
		{
		}

		// log to the event log if posible
		public static void LogToEventLog(string logMessage)
		{	
			const string EventLogSource = "ExceptionManagerInternalException"; // used to log events to event log

			if ( ! EventLog.SourceExists(EventLogSource) ) 
			{
				return;
			}

			logMessage = "CustomSentryPublisher: " + logMessage;
		
			try 
			{
				EventLog.WriteEntry(EventLogSource, logMessage, EventLogEntryType.Warning);
			} 
			catch
			{
			}
		}

		// pick the value for a particular key in a case-insensitive way
		private static string GetValueFromCollectionNoCase(string key, NameValueCollection info)
		{
			if (info == null || info.Count == 0 || key == null) 
			{
				return null;
			}

			key = key.ToLower();

			string[] keys = info.AllKeys;

			for (int i = 0; i < keys.Length; i++) 
			{
				string thisKey = keys[i].ToLower();
				if (thisKey.Equals(key)) 
				{
					string value = info[key];
					return (value == null || value.Length == 0) ? null : value;
				}
			}

			return null;
		}

		// get value of sentryURL config param
		private static string GetSentryURL(NameValueCollection configSettings) 
		{
			const string defaultSentryURL = "http://localhost:9911/wsi/event";

			string sentryURL = GetValueFromCollectionNoCase("sentryURL", configSettings);
			if (sentryURL == null || sentryURL.Length == 0) 
			{
				return defaultSentryURL;
			}
			string origValue = sentryURL; // save it for later use

			sentryURL = sentryURL.TrimEnd(new char[]{'/'}); // trim any trailing slash
			sentryURL = sentryURL.Replace("/soap/event", "/wsi/event");

			if ( ! sentryURL.StartsWith("http://") || ! sentryURL.EndsWith("/wsi/event")) 
			{
				string logMessage = "Invalid value of sentryURL parameter: " + origValue;
				LogToEventLog(logMessage);
				return defaultSentryURL; 
			}

			try
			{
				Uri uri = new Uri(sentryURL);
			} 
			catch (Exception e) 
			{
				string logMessage = "Invalid value of sentryURL: " + origValue + "; " +
					e.GetType() + " : " + e.Message;
				LogToEventLog(logMessage);
				return defaultSentryURL; 
			}

			return sentryURL;
		}

		// get value of sentryQueueLimit config param
		private static int GetSentryQueueLimit(NameValueCollection configSettings)  
		{
			const int QueueLimitMin = 10;
			const int QueueLimitMax = 1000;		
			const int QueueLimitDefault = 100;

			string queueLimitStr = GetValueFromCollectionNoCase("sentryQueueLimit", configSettings);
			if (queueLimitStr == null || queueLimitStr.Length == 0)  
			{
				return QueueLimitDefault;
			}

			int queueLimit = QueueLimitDefault;

			try 
			{
				queueLimit = Int32.Parse(queueLimitStr, NumberStyles.Integer);
			} 
			catch (Exception e) 
			{
				string logMessage = "Invalid value of sentryQueueLimit: " + queueLimitStr + "; " +
					e.GetType() + " : " + e.Message;
				LogToEventLog(logMessage);
				return QueueLimitDefault;
			}

			queueLimit = (queueLimit < QueueLimitMin) ? QueueLimitMin : queueLimit;
			queueLimit = (queueLimit > QueueLimitMax) ? QueueLimitMax : queueLimit;			

			return queueLimit;
		}

		// set up the publisher and its queue processor
		private static void InitializeSentryPublisher(NameValueCollection configSettings)
		{
			string sentryURL = GetSentryURL(configSettings);

			int queueLimit = GetSentryQueueLimit(configSettings);

			QueueProcessor.Initialize(sentryURL, queueLimit);

			configEventAttributeMap = UpdateAttributeMap(new Hashtable(), configSettings);
		}

		// Given a hashmap for event attributes, update it with a NameValueCollection
		private static Hashtable UpdateAttributeMap(Hashtable map, NameValueCollection info)
		{
			if (map == null || info == null) 
			{
				return map;
			}

			string[] keys = info.AllKeys;

			for (int i = 0; i < keys.Length; i++) 
			{
				string key = keys[i];
				EventAttributeType attrib = EventAttributeType.ValueOf(key);
				if (attrib != null) 
				{
					string value = info[key];
					if (value != null && value.Length > 0) 
					{
						map[attrib] = value;
					}
				}
			}

			return map;
		}

		// Build a merged map for event attributes that combines config setting and user-supplied event info
		private static Hashtable CreateUnifiedAttributeMap(Hashtable configEventAttributeMap, NameValueCollection userInfo)
		{
			Hashtable map = UpdateAttributeMap(new Hashtable(configEventAttributeMap), userInfo);

			// Special handling of legacy case where the first item in the userInfo collection
			// is the message field
			if (map[EventAttributeType.MESSAGE] == null && userInfo != null && userInfo.Count > 0) 
			{
				string key = userInfo.GetKey(0);
				if ( ! key.EndsWith(".MachineName") && EventAttributeType.ValueOf(key) == null) 
				{
					string value = userInfo[0];
					map[EventAttributeType.MESSAGE] = key + ": " + value;
				}
			}

			return map;
		}

		// called from the public Publish method
		private static void EnqueueEvent(Exception exception, NameValueCollection userInfo, NameValueCollection configSettings)
		{
			lock (typeof(SentryPublisher)) 
			{
				if ( ! sentryPublisherInitialized ) 
				{
					InitializeSentryPublisher(configSettings);
					sentryPublisherInitialized = true;
				}
			}

			// have a merged map that combines config setting and user-supplied event info
			Hashtable map = CreateUnifiedAttributeMap(configEventAttributeMap, userInfo);
			
			ArrayList list = new ArrayList();

			for (int i = 0; i < EventAttributeType.array.Length; i++) 
			{
				EventAttributeType attrib = EventAttributeType.array[i];
				
				string value = (string) map[attrib];

				// special handling of "ignore" severity level: do nothing
				if (attrib == EventAttributeType.SEVERITY && (Severity.ValueOf(value) == Severity.IGNORE || Severity.ValueOf(value) == null))
				{
					return;
				}

                if (attrib == EventAttributeType.SEVERITY && (Severity.ValueOf(value) == Severity.DEBUG || Severity.ValueOf(value) == Severity.INFO))
                    value = Severity.NORMAL.name;

				if (value == null || value.Length == 0) 
				{
					value = attrib.defaultValue;
				}


				// special handing of object attribute: make use of the exception message
				if (attrib == EventAttributeType.OBJECT && value == null && exception != null )
				{
					value = exception.Message;
				}

				if (value != null) 
				{
					list.Add( new AttributeValuePair(attrib, value) );
				}
			}

			AttributeValuePair[] attributeValuePairs = (AttributeValuePair[]) 
				(list.ToArray(typeof(AttributeValuePair)));

			QueueProcessor.Enqueue(new EventRecord(attributeValuePairs));
		}

		// Only public method of the Publisher class 
		public void Publish(Exception exception, NameValueCollection userInfo, NameValueCollection configSettings)
		{
            bool logAllMessages = false;

            for (int j = 0; j < configSettings.Count; j++)
            {
                string key = configSettings.GetKey(j);

                if ("sentry.logAll".Equals(key))
                {
                    if ("true".Equals(configSettings.Get(key)))
                        logAllMessages = true;
                        
                    break;
                }
            }

            for(int i = 0; i < userInfo.Count; i++)
            {
                string key = userInfo.GetKey(i);

                if(logType.Equals(key))
                {
                    string value = userInfo.Get(key);

                    if (ALARM.Equals(value.ToUpper()))
                        break;
                    else if (!ALARM.Equals(value.ToUpper()))
                    {
                        if (logAllMessages)
                            break;
                        else 
                            return;
                    }
                }
            }

            SentryPublisher.EnqueueEvent(exception, userInfo, configSettings);
		}

        // Only public method of the Publisher class 
        public long Publish(Exception exception, NameValueCollection userInfo, NameValueCollection configSettings, string dummy)
        {
            long logId = 0;
            bool logAllMessages = false;

            for (int j = 0; j < configSettings.Count; j++)
            {
                string key = configSettings.GetKey(j);

                if ("sentry.logAll".Equals(key))
                {
                    if ("true".Equals(configSettings.Get(key)))
                    {
                        logAllMessages = true;
                        break;
                    }
                }
            }

            for (int i = 0; i < userInfo.Count; i++)
            {
                string key = userInfo.GetKey(i);

                if (logType.Equals(key))
                {
                    string value = userInfo.Get(key);

                    if (ALARM.Equals(value.ToUpper()))
                        break;
                    else if (!logAllMessages)
                        return 0;
                }
            }

            SentryPublisher.EnqueueEvent(exception, userInfo, configSettings);

            return logId;
        }
	}
}	
